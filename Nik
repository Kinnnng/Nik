Тема проекта

Пакетный сниффер на Python: захват и анализ сетевого трафика

Цель проекта

Разработать учебное приложение на Python, которое позволяет захватывать сетевые пакеты на выбранном сетевом интерфейсе, выполнять базовый разбор заголовков протоколов и выводить результаты анализа пользователю. Проект предназначен для изучения принципов работы компьютерных сетей и практики анализа сетевого трафика в контролируемой среде (локальный компьютер/локальная сеть).

Задачи

Реализовать захват пакетов на заданном интерфейсе.

Добавить фильтрацию трафика (по протоколам, портам, IP-адресам).

Реализовать разбор основных сетевых протоколов (IP, TCP, UDP, ICMP).

Выводить ключевые параметры пакетов: источник/назначение, порты, тип протокола, размер, время получения.

(Опционально) сохранять результаты в файл (например, CSV/JSON/PCAP) для последующего анализа.

Обеспечить удобный запуск и понятный вывод в консоль/простом GUI.

Функциональные возможности

Выбор сетевого интерфейса (например Ethernet/Wi-Fi/Loopback).

Ограничение количества пакетов и/или времени захвата (например, “захватить 200 пакетов” или “10 секунд”).

Фильтры захвата:

по протоколу: TCP / UDP / ICMP;

по порту: port 80, port 443, port 8000;

по хосту: host 192.168.1.10;

комбинированные правила.

Разбор пакетов:

IP: src/dst, TTL, размер;

TCP: порты, флаги (SYN/ACK/FIN), установление соединений;

UDP: порты и длина;

ICMP: типы сообщений (ping и т.п.).

Статистика:

количество пакетов по протоколам;

топ источников/портов;

средний размер пакета.

Логирование (для отладки программы):

запись событий запуска/остановки, ошибок захвата, настроек фильтра.

Архитектура проекта

Проект удобно разделить на модули:

capture — слой захвата пакетов (инициализация интерфейса, запуск/остановка sniff).

parser — разбор пакета и извлечение полей (IP/TCP/UDP/ICMP).

filters — применение правил фильтрации и настройки BPF (если используется libpcap).

storage — сохранение результатов (файл CSV/JSON или PCAP).

ui — консольное меню/CLI-аргументы (или простой GUI при необходимости).

stats — накопление статистики и вывод итогового отчёта.

Такое разделение помогает не смешивать сетевой захват, обработку и вывод.

Технологии и инструменты

Python 3.x

Библиотека для перехвата пакетов:

чаще всего Scapy (простая для учебных задач),

либо PyShark (обёртка над Wireshark/tshark).

На Windows для стабильного захвата пакетов обычно требуется Npcap (как у Wireshark).

Пример сценария работы (как пользователь будет запускать)

Пользователь запускает программу.

Выбирает интерфейс (например Wi-Fi).

Указывает фильтр (например “tcp port 8000” для локального сервера).

Программа запускает захват и в реальном времени выводит строки вида:

время, src:port → dst:port, протокол, размер, флаги TCP.

По завершении захвата выводится статистика и/или сохраняется файл отчёта.

Ограничения и безопасность

Программа предназначена для учебного использования и тестируется только:

на собственном компьютере,

либо в локальной лабораторной среде с разрешением преподавателя/участников.

Сниффер не выполняет вмешательство в трафик и не изменяет данные: он только читает пакеты и анализирует заголовки. Для снижения рисков полезная нагрузка (payload) может не сохраняться или маскироваться.

Ожидаемый результат

В результате выполнения проекта получается инструмент, который демонстрирует:

как устроен сетевой обмен на уровне пакетов;

чем отличаются TCP и UDP на практике;

как применять фильтры трафика;




# добавить время получения пакета
# решить проблему с Npcap



from scapy.layers.inet import IP, TCP, UDP, ICMP
#Scapy хранит пакет как “слоёный пирог” из протоколов (слоёв).

def parse_packet(pkt) -> dict | None:
    if IP not in pkt:
        return None
# dict — если пакет понятный и его можно разобрать
# None — если пакет не содержит IP-слоя
# Дальше проверям это слой IP или нет
# Если в пакете нет IPv4, то мы его пропускаем, чтобы дальше не словить ошибку
    ip = pkt[IP] # обращаемся к полям IP как к атрибутам
    row = {          
        "src": ip.src, #IP-адрес отправителя
        "dst": ip.dst, #IP-адрес получателя
        "proto": ip.proto, #номер протокола внутри IP
        "len": len(pkt), #размер пакета в байтах
    }
# Транспортый уровень

    if TCP in pkt:
        tcp = pkt[TCP] # достаём TCP слой
        row.update({    #добавляем новые поля в уже созданный словарь
            "l4": "TCP", # 4 проткол
            "sport": int(tcp.sport), #порт отправителя
            "dport": int(tcp.dport), #порт получателя
            "flags": str(tcp.flags),              # трёх этапное рукапожатие
        })
    elif UDP in pkt:
        udp = pkt[UDP]
        row.update({
            "l4": "UDP",
            "sport": int(udp.sport),
            "dport": int(udp.dport),
            "flags": "",
        })
    elif ICMP in pkt:
        icmp = pkt[ICMP]
        row.update({
            "l4": "ICMP",
            "sport": "", #здесь порты не исползуются
            "dport": "",
            "flags": f"type={icmp.type}",
        })
    else:
        row.update({"l4": "OTHER", "sport": "", "dport": "", "flags": ""}) #пустые

    return row



